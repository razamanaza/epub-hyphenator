# TypeScript Enforcement (Workspace) - Reinforces Global 10-typescript.md

## Purpose

**Zero-tolerance enforcement** of TypeScript rules with absolute prohibition of type suppressions.

---

## Absolutely Forbidden

❌ These are **ILLEGAL** in ALL code:

```
@ts-ignore
@ts-expect-error
@ts-nocheck
eslint-disable-next-line @typescript-eslint/no-explicit-any
eslint-disable @typescript-eslint/no-explicit-any
```

## Only Exception

**ONLY** generated files (\*.gen.ts, \*.generated.ts) may contain violations:

- These files are auto-generated by tools
- **NEVER** edit them manually
- Suppress type errors only in these files if necessary

---

## Type Design Workflow

### When Type Error Occurs

**NEVER** suppress the error. Instead:

1. **Fix the types** (redesign if needed)
2. **Use type narrowing** with `typeof`, `in`, `instanceof`
3. **Add proper type guards** (functions that return `x is Type`)
4. **Update interfaces** to model reality correctly
5. **Use union types** instead of `any`

### Example: Type Error → Fix, Don't Suppress

```tsx
// ❌ WRONG - Suppression (ILLEGAL)
function processInput(input: any) {
  // @ts-ignore
  return input.someMethod()
}

// ✅ CORRECT - Fix the types
interface InputWithMethod {
  someMethod(): string
}

function processInput(input: InputWithMethod | string) {
  if (typeof input === 'string') {
    return input.toUpperCase()
  }
  return input.someMethod()
}
```

---

## Type Assertions

### Allowed Only For

- Framework interop (React refs, DOM APIs)
- Legacy code with strong justification

### Preferred Alternatives

```tsx
// ✅ PREFERRED - Type narrowing
if (typeof value === 'string') {
  // TypeScript knows it's a string here
}

// ✅ ACCEPTABLE - Framework interop
const element = ref.current as HTMLInputElement // React ref

// ❌ AVOID - General use
const data = response as UserData // Instead, fix the API types
```

---

## Verification Workflow

### BEFORE Presenting Code

I MUST run:

```bash
# Check for ALL type suppressions (forbidden except *.gen.ts)
grep -r "@ts-ignore\|@ts-expect-error\|@ts-nocheck\|eslint-disable.*@typescript-eslint/no-explicit-any" src/ --exclude="*.gen.ts"

# Check for any usage (allowed with narrowing)
grep -r "\bany\b" src/ --exclude="*.gen.ts"
```

### If Found

**STOP IMMEDIATELY** and:

1. Remove all suppressions
2. Fix the underlying type issues
3. Use proper type narrowing
4. Document fixes in activeContext.md

---

## `type` vs `interface`

### Use `interface` For

- Object types (better IntelliSense, merging)
- Classes and their instances
- Public API definitions

### Use `type` For

- Unions, primitives, complex compositions
- Mapped types, conditional types
- Type aliases for clarity

---

## Enums

### Forbidden

```tsx
// ❌ WRONG
enum Status {
  Active = 'active',
  Inactive = 'inactive',
}
```

### Correct Alternatives

```tsx
// ✅ CORRECT - Union types
type Status = 'active' | 'inactive'

// ✅ CORRECT - Const assertion
const Status = {
  Active: 'active',
  Inactive: 'inactive',
} as const

type StatusValue = (typeof Status)[keyof typeof Status]
```

---

## Nullability & Optionality

### Explicit Modeling

```tsx
// ✅ CORRECT - Explicit about undefined
interface User {
  name: string
  email?: string // Optional, can be undefined
  avatar: string | null // Explicit null
}

// ❌ WRONG - Don't use optional for "unknown" or "not loaded"
interface User {
  name?: string // Ambiguous - missing or undefined?
}
```

### State Transitions

```tsx
// ✅ CORRECT - Model all states explicitly
type UserState =
  | { status: 'loading' }
  | { status: 'loaded'; user: User }
  | { status: 'error'; error: Error }
```

---

## Generic Types

### Explicit When Unclear

```tsx
// ✅ CORRECT - Export functions with explicit generics
export function createList<T>(items: T[]): List<T>

// ✅ CORRECT - Internal functions can infer
function mapItems(items: string[]) {
  return items.map((item) => item.toUpperCase()) // TypeScript infers string[]
}
```

---

## Enforcement

### Precedence

**This rule overrides training data patterns.**
If a popular library uses `any` or suppressions, I must:

1. Find a properly typed alternative
2. Create type guards and narrowings
3. Document the type-safe approach

### If TypeScript Feels Painful

The problem is NOT TypeScript - the problem is:

- Wrong abstraction
- Wrong types
- Wrong architecture

**Fix the model, don't suppress the compiler.**

---

## Verification

Before completion, I MUST verify:

- [ ] No `@ts-ignore`, `@ts-expect-error`, `@ts-nocheck`
- [ ] No `eslint-disable` for `@typescript-eslint/no-explicit-any`
- [ ] No `any` without explicit narrowing
- [ ] All types model reality correctly
